% !TeX root = ../main.tex
\section{Discussion}\label{section:design-discussion}

This section gives a discussion on our design decisions provided in the previous sections.
We present possible alternatives and the reasons why they have been discarded.

Our extension to \whiley has been developed as part of this Master's Thesis.
The extend of work for this thesis is limited to six months, done by a single student.
All implementation and the scientific elaboration had to be done with these limited resources.
This imposes some constraints on the extent of changes that can be made.


\subsection{Backwards-Compatibility}

One goal for our work was to maintain backwards compatibility.
\whiley is still a developing language, such that backwards-incompatible changes are basically possible, but being able to use all existing test cases to see whether our changes break intended behavior and semantics of \whiley was a big benefit.

However, some changes are not fully backwards-compatible:
The introduction of \whileyinline{this} as a keyword breaks every program that uses it as identifier.
Indeed, some test cases and also some components of \whiley's standard library had to be adopted for that change.
But a simple replacement of affected identifiers resolves the problem.

We decided against a requirement to explicitly annotate every reference with a lifetime.
This allows to still compile programs that do not make use of our extension.
The implicit default lifetime for references without explicit annotation therefore had to be a lifetime that does not impose additional constraints to existing programs.
References can be passed between methods, so the default lifetime should outlive all methods.
The legacy notation \whileyinline{&int} can therefore be regarded as syntactic sugar for \whileyinline{&*:int}.

One possibility for future optimization is to infer shorter lifetimes if no explicit lifetimes are given.
As an example, a method whose parameter and return types do not contain any reference types cannot leak references to the caller.
All allocations and references in that method can therefore be assumed to be annotated with lifetime \whileyinline{this} instead of \whileyinline{*}.
But this is not possible for the general case where methods take and return references.
Inferring a shorter lifetime for these programs would need expensive inter-procedural static analysis, which is out of scope for this thesis.


\subsection{Mutability and Move Semantics}\label{section:design-discussion-mutability}
In \whiley, functions have call-by-value semantics.
We can describe call-by-value semantics with two properties:
\begin{enumerate}
\item the caller will not observe any modifications of passed values done within the callee
\item the callee will not observe any concurrent modifications of passed values done by other parts of the program
\end{enumerate}

The second point is trivial as there is not yet a concept for concurrency in \whiley.
The compiler is responsible to ensure the first point.

\rust distinguishes between mutable and immutable values and references.
A primary use for it is to classify borrowed references:
there can either be multiple immutable borrowings or only one mutable borrowing at any time.
Call-by-reference semantics with immutable references is basically the same as call-by-value semantics:
the callee cannot make any changes to the referenced value.
This ensures the first point described above.
Furthermore, the value is borrowed immutable for the time that the callee is executed.
The borrow checker in \rust ensures that the value cannot be mutated during that time, so also the second point holds.

To provide a function with read-only access to a value, we can pass it an immutable reference in \rust.
This is equivalent to calling the function with the value itself in \whiley.
When we want to provide the callee also with write access, we have different options in \rust:
we can pass the value itself.
Ownership will be transferred to the callee and the caller's former variable binding cannot be used anymore.
Alternatively, we can pass a mutable reference to that value.
Then the caller remains owner of the value.
In \whiley, the only option is to pass a reference.
To modify the referenced value, the callee uses the dereference assignment.
The callee therefore needs to be a method, because dereference operations are not allowed in pure functions.

\whiley has a focus on verification.
But verification with references is difficult, as there might be numerous aliases and an assignment can affect multiple variables.
The current verifier in \whiley cannot handle references.

\begin{whileycode}
method main():
	&int x = new 1
	assume (*x) == 1
	*x = 2
	assume (*x) == 2
\end{whileycode}

\noindent Neither of the two verification conditions generated by the \whileyinline{assume} statements passes verification.
It therefore is a good practice to use values instead of references when possible.

\whiley does not have a concept of immutable values or references.
We decided against introducing them for two reasons.
First of all, it is not possible to add the invariant of having only one mutable or several immutable references without breaking backwards compatibility.
Existing programs can create multiple aliases and mutate the value via all of these references.
That invariant is particularly useful in a concurrent setting, as it prevents data races.
But \whiley does not yet have concurrency.

Another point to consider are function or method parameters:
in \rust, a function with two references as parameters where at least one of them is mutable can always assume that they do not point to the same memory.
This is due to the fact that the caller cannot borrow the value mutable and immutable at the same time.
If a method in \whiley relies on the fact that parameters are not aliases of each other, we can simply add an appropriate precondition using \whileyinline{requires}.

Call-by-value as in \whiley and call-by-reference semantics can differ in their performance:
for a call-by-reference semantics we only need to pass an address to the callee.
For call-by-value, the implementation in general needs to generate a deep-copy of the passed value in order to allow the callee to modify an independent copy.
But if there is no such modification the compiler can optimize the code by using a call-by-reference semantics.


\subsection{References to Local Variables}
\rust allows to create references to local variables.
We cannot allow that in \whiley, as it would easily break type safety.
This is due to \emph{flow typing} as described in \myref{section}{section:background-whiley-flow-typing}.
Consider the following program:

\begin{whileycode}
int|null x = 5
&int y = new 42;
if x is int:
	y = &x // invalid syntax!
x = null
int z = *y
\end{whileycode}

Assume line~4 would store a reference to \whileyinline{x} into \whileyinline{y}, similar to \rust's borrowed references.
Due to flow typing, the static type of \whileyinline{x} in line~4 is \whileyinline{int}.
Therefore the assignment in line~4 is fine.
In line~5, \whileyinline{x} has again type \whileyinline{int|null}.
Therefore we should be able to assign \whileyinline{null} to it.
In line~6, we dereference \whileyinline{y}.
It expects type \whileyinline{&int} and therefore should yield an integer.
But the actual value will be \whileyinline{null}!

Flow typing relies on the fact that there are no aliases for local variables.
Allowing to create references to local variables would introduce these aliases.
As there is no easy solution to keep flow typing in a backwards-compatible way while handling aliases, our extension does not allow creating references to local variables.


\subsection{Pointer Types}
As discussed in \myref{section}{section:design-discussion-mutability}, references are a challenge for verification.
While values in \whiley cannot have aliases we always have to consider side-effects when calling a method with references or doing dereference assignments.
\rust offers several different type of values and pointers:
First of all, there is the owned value itself.
It can be mutable or immutable.
Furthermore, there are borrowed references, \rustinline{Box}, \rustinline{Rc} and \rustinline{Arc}.
Each of them comes with different advantages and benefits.
The choice of the right type suitable for the specific use-case is important.
Changing your decision later on involves refactoring all types, e.g. in function signatures or explicitly typed variable bindings.
In its current state, \whiley should remain as simple as possible.
This is also the reason why the former support for floating point numbers has been removed during recent development\footnote{\url{http://whiley.org/2016/01/29/whiley-v0-3-38-released/}}.
\rust offers these different types to be as performant as possible:
the types provide different trade-offs between imposed restrictions and runtime overhead.
An \rustinline{Arc<Box<T>>} can always be used instead of \rustinline{&T}, but the additional overhead might not be necessary.

As described above, references to local variables are not a feasible option for our extension.
Instead, we need to have all references memory to be allocated using the \whileyinline{new} operator.
The compiler needs to decide whether the allocated memory can be placed on the stack and therefore use a similar performance as local variables.
A key input to that decision are lifetimes.
The \whiley reference type \whileyinline{&T} is similar to \rust's type \rustinline{Rc<Box<T>>}.
Our extension leaves it up to the compiler to optimize that type to an equivalent of \rustinline{&T}.
The \whiley language itself stays simple, as the decision where to allocate the memory is delegated to the compiler.
The programmer can influence that process by annotating lifetimes, telling the compiler how long an allocation can be accessed.
Without lifetime annotations, the backwards-compatible default will be assumed.


\subsection{Lambda Expressions}\label{section:design-discussion-lambda}
Lambda expressions allow to declare anonymous functions and methods.
They differ from normal functions and methods in such a way that they are declared in a context.
We can access variables that are declared outside from inside the lambda expression:

\begin{whileycode}
method main():
	int x = 5
	function(int)->(int) f = &(int y -> x + y)
	int z = f(3)
	assert z == 8
\end{whileycode}

Even though variable \whileyinline{x} is declared in method \whileyinline{main}, we can still access it in the anonymous function declared in line~3.
We can assume that these anonymous functions store a copy of all accessed variables that are declared in the outer context.
For actual values this works well.
When it comes to references, then we have to ensure that the memory pointed to is still alive.
This is trivial when using garbage collection, but consider the following program using our extension:

\begin{whileycode}
method generateLambda() -> method(int)->(int):
	&this:int x = this:new 5
	method(int)->(int) f = &(int y -> (*x) + y)
	return f

method main():
	method(int)->(int) f = generateLambda()
	int z = f(3)
\end{whileycode}

Similar to our first example, we have an anonymous method declared in line~3 that accesses the variable \whileyinline{x} declared in line~2.
It is important to realize that \whileyinline{x} does not hold an integer.
It holds a reference, i.e. the address of a memory location holding that integer.
The lambda expression therefore stores a copy of that address.
The address is dereferenced inside the lambda expression.

Our lifetime extension suggests that \whileyinline{x} should be allocated on the stack, because its annotated lifetime is \whileyinline{this}.
That implies that the memory holding our value \whileyinline{5} is freed when \whileyinline{generateLambda} returns.
But the actual dereference operation to that memory happens afterwards, due to the call of method \whileyinline{f} in line~8.
We dereference freed memory!

There are two general approaches to prevent that problem:
first of all we can forbid to use the dereference operator inside lambda expressions, or at least forbid dereferencing of variables that are part of the lambda's context.
The second approach is to prevent calling lambda expressions after the end of a lifetime that is dereferenced inside.
We selected the second choice, because it is less restrictive.

The lifetimes of references from the lambda's context that are dereferenced inside the lambda expression are called \emph{context lifetimes}.
In the example above, \whileyinline{this} is a context lifetime for the lambda expression declared in line~3 because \whileyinline{x} is dereferenced inside the lambda expression but declared outside and its lifetime is \whileyinline{this}.
The programmer has to specify a set of context lifetimes that he wants to dereference inside the lambda expression: \whileyinline{&[this](int y -> (*x) + y)}.
Furthermore, the context lifetimes are part of the method's type: \whileyinline{method[this](int)->(int)}.
These context lifetimes are considered to be using occurrences, i.e. the specified lifetime names need to be declared before and still be in scope.
This is what ensures effectiveness of our approach.
In the program above, we can add the context lifetime to both the lambda expression itself and its type in line~3.
But we cannot add it to the return type of \whileyinline{generateLambda}, because lifetime \whileyinline{this} is only valid in the method body and not in return types.

To call a lambda method we need to access its value.
The value can be stored in a local variable, in an array or in a record.
In all cases, its declaration will be in scope.
The declaration states the type, containing the method's context lifetimes.
This transitively ensures that the context lifetimes are still in scope when calling a lambda function.
therefore also all context lifetimes will be in scope.

When type-checking a dereference operation inside a lambda expression, the compiler now has to extract the lifetime of the given reference.
It has to be part of the context lifetimes.
Alternatively, the context lifetimes may also contain a lifetime that outlives the reference's lifetime.

Context lifetimes have to be considered for subtyping.
First of all, there is no order among context lifetimes.
They can be treated as sets, i.e. all of the three types \whileyinline{method[a,b]()->()}, \whileyinline{method[a,b]()->()}, and \whileyinline{method[a,b,a]()->()} are equivalent.
If a method is allowed to access some context lifetimes but actually does make use of it, then the execution is still save.
Subtypes therefore can have a subset of the supertype's context lifetimes.
Consider the case that the method type declares \whileyinline{b} as context lifetime.
That imposes a restriction that the method can only be executed while \whileyinline{b} is still in scope.
If there is another lifetime \whileyinline{a} that outlives \whileyinline{b}, then it is also safe to dereference references with lifetime  \whileyinline{a}.
We therefore define the following restriction for subtyping among references:
every context lifetime in the subtype must outlive a context lifetime in the supertype.
